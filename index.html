<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>æ˜Ÿå…‰åœ£è¯æ ‘ (Ultimate Stable)</title>
    <style>
        /* --- åŸºç¡€è®¾ç½® --- */
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at 50% 50%, #1b2735 0%, #090a0f 100%);
            font-family: "Microsoft YaHei", -apple-system, sans-serif;
            color: #ffd700;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }

        /* --- å¯åŠ¨é®ç½©å±‚ --- */
        #start-screen {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 8, 16, 0.98);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #start-btn {
            background: linear-gradient(135deg, #d4af37, #f7e08b);
            border: none;
            padding: 16px 45px;
            font-size: 1.2rem;
            font-weight: bold;
            color: #222;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 0 25px rgba(212, 175, 55, 0.5);
            margin-top: 30px;
            transition: all 0.3s;
            opacity: 0.5; /* é»˜è®¤åŠé€æ˜ä¸å¯ç‚¹ */
            pointer-events: none;
        }
        #start-btn.ready {
            opacity: 1;
            pointer-events: auto;
            animation: pulse 2s infinite;
        }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        .status-text { color: #fff; line-height: 1.6; margin-bottom: 10px; font-weight: 300; }
        .error-log { 
            color: #ff6b6b; font-size: 0.8rem; margin-top: 20px; 
            background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; 
            max-width: 90%; word-break: break-all; display: none;
        }

        /* --- UI --- */
        #ui-layer, #counter-panel, #webcam-preview { display: none; } /* åˆå§‹éšè— */
        
        #ui-layer { position: absolute; top: env(safe-area-inset-top, 20px); right: 20px; z-index: 10; display: none; flex-direction: column; align-items: flex-end; gap: 12px; pointer-events: none; }
        .glass-panel, #upload-btn { pointer-events: auto; }
        
        #counter-panel { position: absolute; top: env(safe-area-inset-top, 20px); left: 20px; z-index: 10; display: none; padding: 12px 16px; }

        .glass-panel { background: rgba(30, 40, 60, 0.65); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 215, 0, 0.2); border-radius: 16px; color: #fff; transition: all 0.3s; overflow: hidden; }
        
        #guide-panel { padding: 0 15px; min-width: 160px; }
        .panel-header { display: flex; justify-content: space-between; align-items: center; height: 44px; cursor: pointer; }
        h1 { margin: 0; font-size: 1rem; color: #ffd700; text-shadow: 0 0 10px rgba(212, 175, 55, 0.4); }
        .toggle-icon { color: #aaccff; font-size: 0.8rem; transition: transform 0.3s; }
        .instruction-content { max-height: 400px; opacity: 1; transition: 0.4s ease; margin-bottom: 15px; }
        .glass-panel.collapsed .instruction-content { max-height: 0; opacity: 0; margin-bottom: 0; }
        .glass-panel.collapsed .toggle-icon { transform: rotate(-90deg); }
        .instruction-box { display: flex; flex-direction: column; gap: 12px; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; }
        .instruction { font-size: 0.85rem; color: #e0e6ff; display: flex; align-items: center; gap: 10px; }
        .icon { font-size: 1.4rem; min-width: 28px; text-align: center; }
        .action-highlight { color: #ffe066; font-weight: 600; display: block; }
        .desc { font-size: 0.75rem; color: #9ab; line-height: 1.2; }

        #upload-btn { background: linear-gradient(135deg, #1c3d5a, #2b4c6f); border: 1px solid rgba(160, 200, 255, 0.3); color: #fff; padding: 12px 24px; border-radius: 30px; cursor: pointer; font-weight: 600; font-size: 0.9rem; box-shadow: 0 4px 15px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; gap: 8px; width: fit-content; }
        #upload-btn.processing { opacity: 0.7; pointer-events: none; }

        #webcam-preview { position: absolute; bottom: max(20px, env(safe-area-inset-bottom)); left: 20px; width: 100px; height: 75px; z-index: 10; border-radius: 8px; border: 2px solid rgba(255, 215, 0, 0.4); opacity: 0.7; transform: scaleX(-1); object-fit: cover; background: #000; }
        .counter-text { font-size: 1.3rem; font-weight: bold; color: #aaccff; font-family: monospace; }
        .counter-label { font-size: 0.7rem; color: #8899aa; text-transform: uppercase; }
        
        #safari-hint { display: none; margin-top: 20px; padding: 10px; border: 1px solid #d4af37; border-radius: 8px; color: #ccc; font-size: 0.8rem; }
    </style>
</head>
<body>

    <!-- å¯åŠ¨å±å¹• -->
    <div id="start-screen">
        <div style="font-size: 3rem; margin-bottom: 20px;">ğŸ„</div>
        <div class="status-text" id="status-msg">
            <b>æ˜Ÿå…‰åœ£è¯æ ‘</b><br>æ­£åœ¨è¿æ¥æœåŠ¡å™¨ (0%)...
        </div>
        
        <div id="safari-hint">
            âš ï¸ <b>iOS ç”¨æˆ·è¯·æ³¨æ„ï¼š</b><br>å¦‚æ— æ³•å¯åŠ¨ï¼Œè¯·å¤åˆ¶é“¾æ¥åœ¨ Safari æµè§ˆå™¨ä¸­æ‰“å¼€ã€‚
        </div>

        <div class="error-log" id="error-log"></div>
        <button id="start-btn">ç­‰å¾…èµ„æºåŠ è½½</button>
    </div>

    <!-- ä¸»ç•Œé¢ -->
    <div id="counter-panel" class="glass-panel">
        <div class="counter-label">MEMORIES</div>
        <div id="photo-count-display" class="counter-text">0 / 40</div>
    </div>

    <div id="ui-layer">
        <div class="glass-panel" id="guide-panel">
            <div class="panel-header" id="guide-toggle">
                <h1>ğŸŒŒ æ˜Ÿé™…æŒ‡å—</h1>
                <span class="toggle-icon">â–¼</span>
            </div>
            <div class="instruction-content">
                <div class="instruction-box">
                    <div class="instruction"><span class="icon">âœŠ</span><div><span class="action-highlight">æ¡æ‹³</span><div class="desc">æ¶¡è½®èšåˆåœ£è¯æ ‘</div></div></div>
                    <div class="instruction"><span class="icon">ğŸ–</span><div><span class="action-highlight">å¼ å¼€</span><div class="desc">æ˜Ÿå°˜ç‚¸è£‚ (é™æ­¢è‡ªè½¬)</div></div></div>
                    <div class="instruction"><span class="icon">ğŸ‘‹</span><div><span class="action-highlight">ç§»åŠ¨</span><div class="desc">è·Ÿéšæ‰‹åŠ¿æ—‹è½¬</div></div></div>
                    <div class="instruction"><span class="icon">ğŸ¤</span><div><span class="action-highlight">æåˆ</span><div class="desc">æŠ“å–è®°å¿†ç¢ç‰‡</div></div></div>
                </div>
            </div>
        </div>
        
        <input type="file" id="file-input" multiple accept="image/*" style="display: none;">
        <button id="upload-btn"><span>âœ¨</span> ä¸Šä¼ è®°å¿†</button>
    </div>

    <video id="webcam-preview" autoplay playsinline webkit-playsinline muted></video>
    <div id="canvas-container"></div>

    <!-- ä¾èµ–åº“é…ç½® -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/+esm",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm",
                "gsap": "https://cdn.jsdelivr.net/npm/gsap@3.12.5/index.js"
            }
        }
    </script>

    <script>
        // --- å…¨å±€é”™è¯¯æ•è· ---
        window.onerror = function(msg, url, line) {
            const log = document.getElementById('error-log');
            log.style.display = 'block';
            log.innerHTML = `âš ï¸ åŠ è½½é”™è¯¯: ${msg} <br> (Line: ${line})`;
            document.getElementById('status-msg').innerHTML = "ç½‘ç»œè¿æ¥ä¸ç¨³å®š<br>è¯·å°è¯•åˆ‡æ¢ WiFi/4G æˆ–å¼€å¯ VPN";
        };

        // --- ç®€å• UI é€»è¾‘ ---
        document.getElementById('guide-toggle').onclick = function() {
            document.getElementById('guide-panel').classList.toggle('collapsed');
        };
        
        document.getElementById('upload-btn').onclick = function() {
            document.getElementById('file-input').click();
        }

        // --- iOS æ£€æµ‹ ---
        if (/iPhone|iPad|iPod/.test(navigator.userAgent) && !/Safari/.test(navigator.userAgent)) {
            document.getElementById('safari-hint').style.display = 'block';
        }
    </script>

    <script type="module">
        // å¯¼å…¥æ¨¡å—
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';
        import gsap from 'gsap';

        // --- èµ„æºåŠ è½½æˆåŠŸï¼Œæ¿€æ´»æŒ‰é’® ---
        const startBtn = document.getElementById('start-btn');
        const statusMsg = document.getElementById('status-msg');
        
        statusMsg.innerHTML = "<b>æ˜Ÿå…‰åœ£è¯æ ‘</b><br>èµ„æºå°±ç»ªï¼Œè¯·ç‚¹å‡»å¼€å§‹";
        startBtn.innerText = "å¼€å¯é­”æ³•";
        startBtn.classList.add('ready');
        
        // ç»‘å®šç‚¹å‡»äº‹ä»¶ (è¿™æ˜¯æœ€å®‰å…¨çš„æ–¹å¼)
        startBtn.onclick = async function() {
            startBtn.innerText = "æ­£åœ¨å¯åŠ¨...";
            startBtn.classList.remove('ready'); // é˜²æ­¢é‡å¤ç‚¹å‡»
            try {
                await init();
                await setupMediaPipe();
                
                // å¯åŠ¨æˆåŠŸï¼Œåˆ‡æ¢ç•Œé¢
                const screen = document.getElementById('start-screen');
                screen.style.opacity = 0;
                setTimeout(() => {
                    screen.style.display = 'none';
                    document.getElementById('guide-panel').classList.add('collapsed');
                }, 500);
                
                document.getElementById('ui-layer').style.display = 'flex';
                document.getElementById('counter-panel').style.display = 'block';
                document.getElementById('webcam-preview').style.display = 'block';
                
            } catch (err) {
                console.error(err);
                document.getElementById('error-log').style.display = 'block';
                document.getElementById('error-log').innerHTML = `å¯åŠ¨å¤±è´¥: ${err.message}`;
                startBtn.innerText = "ç‚¹å‡»é‡è¯•";
                startBtn.classList.add('ready');
            }
        };

        // --- æ ¸å¿ƒé€»è¾‘ ---
        const CONFIG = {
            colors: { green: 0x2d5a3f, gold: 0xFFD700, red: 0xcc2222, white: 0xFFFFFF },
            particleCount: 550, treeHeight: 45, treeRadius: 16, scatterRadius: 90, maxPhotos: 40 
        };

        let scene, camera, renderer, composer;
        let handLandmarker;
        let particles = []; 
        let photoData = []; 
        let currentState = 'tree'; 
        let targetRotation = { x: 0, y: 0 };
        const group = new THREE.Group();
        
        let starMesh, ribbonMesh, backgroundStars, sparklesPoints, starTexture;
        let lastHandPos = { x: 0.5, y: 0.5 };
        let isHandStatic = false;
        let handStaticCounter = 0;
        let isInitialized = false;

        // å›¾ç‰‡å‹ç¼©
        function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = (event) => {
                    const img = new Image();
                    img.src = event.target.result;
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const MAX_SIZE = 512;
                        let w = img.width, h = img.height;
                        if (w > h) { if (w > MAX_SIZE) { h *= MAX_SIZE/w; w = MAX_SIZE; } } 
                        else { if (h > MAX_SIZE) { w *= MAX_SIZE/h; h = MAX_SIZE; } }
                        canvas.width = w; canvas.height = h;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, w, h);
                        canvas.toBlob((blob) => {
                            resolve({ url: URL.createObjectURL(blob), aspect: w/h });
                        }, 'image/jpeg', 0.9);
                    };
                    img.onerror = reject;
                };
                reader.onerror = reject;
            });
        }

        // ç”Ÿæˆæ˜ŸèŠ’çº¹ç†
        function createLensflareTexture() {
            const cvs = document.createElement('canvas'); cvs.width=128; cvs.height=128;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#000'; ctx.fillRect(0,0,128,128);
            const g = ctx.createRadialGradient(64,64,0, 64,64,64);
            g.addColorStop(0, 'rgba(255,255,240,1)'); g.addColorStop(0.3, 'rgba(255,220,100,0.4)'); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g; ctx.fillRect(0,0,128,128);
            ctx.globalCompositeOperation = 'lighter';
            function beam(w,l,a,alp) {
                ctx.save(); ctx.translate(64,64); ctx.rotate(a);
                const lg = ctx.createLinearGradient(-w/2,0,w/2,0);
                lg.addColorStop(0,'rgba(0,0,0,0)'); lg.addColorStop(0.5,`rgba(255,255,255,${alp})`); lg.addColorStop(1,'rgba(0,0,0,0)');
                ctx.fillStyle=lg; ctx.fillRect(-w/2,-l/2,w,l); ctx.restore();
            }
            beam(5,120,0,0.9); beam(5,120,Math.PI/2,0.9); beam(2,80,Math.PI/4,0.5); beam(2,80,-Math.PI/4,0.5);
            const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        async function init() {
            if(isInitialized) return;
            const container = document.getElementById('canvas-container');
            starTexture = createLensflareTexture();

            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x111622, 0.012);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 80);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.2;
            container.appendChild(renderer.domElement);

            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.4; bloomPass.strength = 1.0; bloomPass.radius = 0.6;
            composer = new EffectComposer(renderer); composer.addPass(renderScene); composer.addPass(bloomPass);

            // å…‰ç…§è°ƒæ•´ï¼šç§»é™¤åŠçƒå…‰ï¼Œå¢å¼ºè¡¥å…‰
            const amb = new THREE.AmbientLight(0xffffff, 2.5); scene.add(amb);
            const key = new THREE.SpotLight(0xffeebb, 1000); key.position.set(30,50,60); key.angle=Math.PI/5; key.penumbra=0.5; scene.add(key);
            const fill = new THREE.PointLight(0x6688cc, 1500); fill.position.set(-40,10,20); scene.add(fill);
            const rim = new THREE.DirectionalLight(0xaaccff, 1.8); rim.position.set(0,20,-50); scene.add(rim);

            scene.add(group);

            createBackgroundStars(); createRibbon(); createStar(); generateParticles(); createSparkleSystem();

            window.addEventListener('resize', onWindowResize);
            setupFileInput();
            animate();
            isInitialized = true;
        }

        // --- 3D å¯¹è±¡æ„å»ºå‡½æ•° ---
        function createBackgroundStars() {
            const geo = new THREE.BufferGeometry(); const pos=[], col=[];
            for(let i=0; i<1500; i++) {
                const r=250+Math.random()*300, th=Math.random()*Math.PI*2, ph=Math.acos((Math.random()*2)-1);
                pos.push(r*Math.sin(ph)*Math.cos(th), r*Math.sin(ph)*Math.sin(th), r*Math.cos(ph));
                const c=new THREE.Color(); c.setHSL(Math.random()*0.2+0.5, 0.2, Math.random()*0.5+0.5);
                col.push(c.r,c.g,c.b);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
            const mat = new THREE.PointsMaterial({size:2, vertexColors:true, map:starTexture, transparent:true, opacity:0.7, blending:THREE.AdditiveBlending, depthWrite:false});
            backgroundStars = new THREE.Points(geo, mat); scene.add(backgroundStars);
        }

        function createStar() {
            const shape=new THREE.Shape(); const o=3.2, inr=1.4;
            for(let i=0;i<10;i++) {
                const r=(i%2===0)?o:inr, a=(i/10)*Math.PI*2;
                if(i===0) shape.moveTo(Math.cos(a+Math.PI/2)*r, Math.sin(a+Math.PI/2)*r);
                else shape.lineTo(Math.cos(a+Math.PI/2)*r, Math.sin(a+Math.PI/2)*r);
            }
            shape.closePath();
            const geo = new THREE.ExtrudeGeometry(shape, {depth:0.8, bevelEnabled:true, bevelThickness:0.3, bevelSize:0.2, bevelSegments:3});
            const mat = new THREE.MeshStandardMaterial({color:0xFFD700, emissive:0xffaa00, emissiveIntensity:1.0, metalness:0.9, roughness:0.1});
            starMesh = new THREE.Mesh(geo, mat); starMesh.position.set(0, CONFIG.treeHeight/2+2.5, 0);
            starMesh.userData = { treePos: starMesh.position.clone(), isStar:true, originalScale:new THREE.Vector3(1,1,1) };
            group.add(starMesh); particles.push(starMesh);
        }

        function createRibbon() {
            class S extends THREE.Curve {
                getPoint(t) {
                    const r=(1-t)*(CONFIG.treeRadius+3)+0.5, y=(t-0.5)*CONFIG.treeHeight, a=t*Math.PI*10;
                    return new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
                }
            }
            const geo = new THREE.TubeGeometry(new S(), 140, 0.35, 8, false);
            const cvs = document.createElement('canvas'); cvs.width=256; cvs.height=1;
            const ctx = cvs.getContext('2d'); const g = ctx.createLinearGradient(0,0,256,0);
            g.addColorStop(0,'red'); g.addColorStop(0.2,'#ffd700'); g.addColorStop(0.4,'green'); g.addColorStop(0.6,'blue'); g.addColorStop(1,'red');
            ctx.fillStyle=g; ctx.fillRect(0,0,256,1);
            const tex = new THREE.CanvasTexture(cvs); tex.colorSpace = THREE.SRGBColorSpace;
            const mat = new THREE.MeshStandardMaterial({map:tex, transparent:true, opacity:0.95, emissive:0x444444, side:THREE.DoubleSide, roughness:0.4, metalness:0.6});
            ribbonMesh = new THREE.Mesh(geo, mat); group.add(ribbonMesh);
        }

        function createSparkleSystem() {
            if(sparklesPoints) { group.remove(sparklesPoints); sparklesPoints.geometry.dispose(); }
            const cnt=800, geo=new THREE.BufferGeometry(), pos=[], sizes=[], speeds=[], offs=[];
            for(let i=0; i<cnt; i++) {
                // ä¿®å¤ï¼šåˆå§‹åŒ–ä½ç½®ç§»é™¤å±å¹•
                pos.push(9999,9999,9999); 
                sizes.push(2.5+Math.random()*4); speeds.push(3+Math.random()*4); offs.push(Math.random()*Math.PI*2);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
            geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes,1));
            geo.setAttribute('speed', new THREE.Float32BufferAttribute(speeds,1));
            geo.setAttribute('offset', new THREE.Float32BufferAttribute(offs,1));
            const mat = new THREE.PointsMaterial({size:3, map:starTexture, transparent:true, opacity:1, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:false, color:0xffffff});
            sparklesPoints = new THREE.Points(geo, mat); group.add(sparklesPoints);
        }

        function updateSparkles(t) {
            if(!sparklesPoints || !particles.length) return;
            const pos = sparklesPoints.geometry.attributes.position.array;
            const spd = sparklesPoints.geometry.attributes.speed.array;
            const off = sparklesPoints.geometry.attributes.offset.array;
            let idx=0; const max=800;
            for(let i=0; i<particles.length; i++) {
                if(idx>=max) break;
                const p = particles[i];
                if(p.userData.isBauble || p.userData.isNeedle || Math.random()>0.85) {
                    pos[idx*3] = p.position.x; pos[idx*3+1] = p.position.y; pos[idx*3+2] = p.position.z;
                    const f = Math.pow(Math.sin(t*spd[idx]+off[idx]), 8);
                    if(f>0.4) pos[idx*3+2]+=0.8; else pos[idx*3]=99999;
                    idx++;
                }
            }
            sparklesPoints.geometry.attributes.position.needsUpdate = true;
        }

        function generateParticles() {
            const kept = particles.filter(p=>p.userData.isStar);
            particles.forEach(p=>{if(!p.userData.isStar) group.remove(p)});
            particles=[...kept];
            const geos = [new THREE.SphereGeometry(0.7,32,32), new THREE.TetrahedronGeometry(0.8,0), new THREE.OctahedronGeometry(0.6,0)];
            const mats = [
                new THREE.MeshStandardMaterial({color:CONFIG.colors.gold, metalness:1, roughness:0.1}),
                new THREE.MeshStandardMaterial({color:CONFIG.colors.green, roughness:0.6, metalness:0.1}),
                new THREE.MeshStandardMaterial({color:0x88ccff, metalness:0.9, roughness:0, transparent:true, opacity:0.8})
            ];
            let placed=0;
            for(let i=0; i<CONFIG.particleCount; i++) {
                let mesh, isPhoto=false, isNeedle=false, isBauble=false;
                if(placed<photoData.length && placed<Math.floor((i/CONFIG.particleCount)*photoData.length+0.5)) {
                    const d=photoData[placed++]; const h=3.5, w=h*d.aspect;
                    mesh = new THREE.Mesh(new THREE.PlaneGeometry(w,h), new THREE.MeshBasicMaterial({map:d.texture, side:THREE.DoubleSide}));
                    const fm = new THREE.Mesh(new THREE.BoxGeometry(w+0.1,h+0.1,0.05), new THREE.MeshStandardMaterial({color:0xffd700, metalness:1, roughness:0.2}));
                    fm.position.z=-0.05; mesh.add(fm); isPhoto=true;
                } else {
                    const ti = Math.floor(Math.random()*geos.length);
                    mesh = new THREE.Mesh(geos[ti], mats[ti]);
                    if(ti===1) isNeedle=true; if(ti===0) isBauble=true;
                }
                const t=i/CONFIG.particleCount, a=t*Math.PI*30+Math.random()*0.5, h=CONFIG.treeHeight, y=-h/2+t*h, r=(1-t)*CONFIG.treeRadius+1.5;
                const tp = new THREE.Vector3(Math.cos(a)*r, y, Math.sin(a)*r);
                const sp = new THREE.Vector3((Math.random()-0.5)*CONFIG.scatterRadius, (Math.random()-0.5)*CONFIG.scatterRadius, (Math.random()-0.5)*CONFIG.scatterRadius);
                mesh.position.copy(tp);
                if(isPhoto) { mesh.lookAt(0,y,0); mesh.rotateY(Math.PI); } else { mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0); }
                mesh.userData = { treePos:tp, scatterPos:sp, isPhoto, isNeedle, isBauble, originalScale:mesh.scale.clone(), treeRot:mesh.rotation.clone() };
                group.add(mesh); particles.push(mesh);
            }
            createSparkleSystem();
        }

        // --- çŠ¶æ€ä¸åŠ¨ç”» ---
        function switchState(newState, extra=null) {
            if(currentState===newState && newState!=='photo') return;
            currentState=newState;

            if(ribbonMesh) {
                if(newState==='tree') { ribbonMesh.visible=true; gsap.to(ribbonMesh.material,{opacity:0.95,duration:3.5}); gsap.to(ribbonMesh.scale,{x:1,y:1,z:1,duration:3.5,ease:"power3.inOut"}); }
                else { gsap.to(ribbonMesh.material,{opacity:0,duration:1}); gsap.to(ribbonMesh.scale,{x:0.1,y:0.1,z:0.1,duration:1,onComplete:()=>{if(currentState!=='tree') ribbonMesh.visible=false}}); }
            }

            if(newState==='tree') {
                const cy=group.rotation.y;
                gsap.fromTo(group.rotation, {y:cy}, {y:cy+Math.PI*4, duration:3.5, ease:"power3.inOut"});
                gsap.to(group.rotation, {x:0, duration:3.5, ease:"power3.inOut"});
            } else if(newState==='photo') {
                gsap.to(group.rotation, {x:0, y:0, z:0, duration:1.5, ease:"power3.inOut"});
            }

            particles.forEach(m => {
                let tp, tr, ts=m.userData.originalScale.clone(), d=(newState==='tree')?(3+Math.random()*0.5):(1.5+Math.random()*0.5), ez="power3.inOut";
                if(m.userData.isStar) {
                    if(newState==='tree') { m.visible=true; tp=m.userData.treePos; gsap.to(m.scale,{x:1,y:1,z:1,duration:3,ease:"elastic.out(1,0.5)"}); }
                    else { tp=m.userData.treePos; gsap.to(m.scale,{x:0.01,y:0.01,z:0.01,duration:0.5,onComplete:()=>m.visible=false}); }
                    tr={x:0,y:m.rotation.y,z:0};
                } else {
                    if(newState==='tree') { tp=m.userData.treePos; const r=m.userData.treeRot; tr={x:r.x,y:r.y,z:r.z}; }
                    else if(newState==='scatter') { tp=m.userData.scatterPos; tr={x:Math.random()*6,y:Math.random()*6,z:Math.random()*6}; }
                    else if(newState==='photo') {
                        if(m===extra) { tp=new THREE.Vector3(0,0,55); tr={x:0,y:0,z:0}; ts.multiplyScalar(3.5); }
                        else { tp=m.userData.scatterPos.clone().normalize().multiplyScalar(150); tr={x:m.rotation.x,y:m.rotation.y,z:m.rotation.z}; }
                    }
                }
                gsap.to(m.position, {x:tp.x,y:tp.y,z:tp.z, duration:d, ease:ez});
                if(newState!=='photo' || m===extra) gsap.to(m.rotation, {x:tr.x,y:tr.y,z:tr.z, duration:d, ease:ez});
                gsap.to(m.scale, {x:ts.x,y:ts.y,z:ts.z, duration:d, ease:ez});
            });
        }

        async function setupMediaPipe() {
            // æ˜ç¡®æŒ‡å®š WASM è·¯å¾„ï¼Œè§£å†³ iOS 404
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task", delegate:"GPU"},
                runningMode:"VIDEO", numHands:1
            });
            const v = document.getElementById('webcam-preview');
            const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user',width:{ideal:640},height:{ideal:480}}});
            v.srcObject = stream; v.play(); v.addEventListener('loadeddata', predictWebcam);
        }

        let lvt=-1;
        async function predictWebcam() {
            const v = document.getElementById('webcam-preview');
            if(handLandmarker && v.currentTime!==lvt && v.videoWidth>0) {
                lvt=v.currentTime; handleGestures(handLandmarker.detectForVideo(v, performance.now()));
            }
            requestAnimationFrame(predictWebcam);
        }

        function handleGestures(res) {
            if(!res.landmarks || !res.landmarks.length) { isHandStatic=true; return; }
            const lm=res.landmarks[0], pc=lm[9];
            const d=Math.hypot(pc.x-lastHandPos.x, pc.y-lastHandPos.y);
            if(d<0.008) handStaticCounter++; else handStaticCounter=0;
            isHandStatic=(handStaticCounter>10); lastHandPos={x:pc.x,y:pc.y};
            
            const pinch = Math.hypot(lm[8].x-lm[4].x, lm[8].y-lm[4].y)<0.05;
            let f=0; if(lm[8].y<lm[6].y) f++; if(lm[12].y<lm[10].y) f++; if(lm[16].y<lm[14].y) f++; if(lm[20].y<lm[18].y) f++;
            
            if(pinch) {
                if(currentState==='scatter') {
                    const p = particles.filter(x=>x.userData.isPhoto);
                    if(p.length) switchState('photo', p[Math.floor(Math.random()*p.length)]);
                }
            } else if(f===0) switchState('tree');
            else if(f>=4) switchState('scatter');

            if(currentState==='scatter' && f>=4 && !isHandStatic) {
                targetRotation.x = (lm[9].y-0.5)*5; targetRotation.y = (lm[9].x-0.5)*-5;
            }
        }

        function setupFileInput() {
            document.getElementById('file-input').addEventListener('change', async (e) => {
                const files = Array.from(e.target.files);
                if(!files.length) return;
                const rem = CONFIG.maxPhotos - photoData.length;
                const add = files.slice(0, rem);
                if(!add.length) { alert("è®°å¿†å·²æ»¡"); return; }
                document.getElementById('upload-btn').classList.add('processing');
                
                let loaded=0; const ldr = new THREE.TextureLoader();
                for(let f of add) {
                    try {
                        const {url, aspect} = await compressImage(f);
                        ldr.load(url, (t) => {
                            t.colorSpace = THREE.SRGBColorSpace; t.minFilter = THREE.LinearFilter;
                            photoData.push({texture:t, aspect}); loaded++;
                            document.getElementById('photo-count-display').innerText = `${photoData.length} / ${CONFIG.maxPhotos}`;
                            if(loaded===add.length) {
                                generateParticles();
                                if(currentState==='tree') switchState('tree');
                                document.getElementById('upload-btn').classList.remove('processing');
                            }
                        });
                    } catch(err){}
                }
            });
        }

        function onWindowResize() {
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate); const t=Date.now()*0.001;
            if(currentState==='tree') group.rotation.y = Math.sin(t*0.15)*0.1;
            else if(currentState==='scatter') {
                if(isHandStatic) { group.rotation.y+=0.002; group.rotation.x+=(0-group.rotation.x)*0.02; }
                else { group.rotation.x+=(targetRotation.x-group.rotation.x)*0.05; group.rotation.y+=(targetRotation.y-group.rotation.y)*0.05; }
            }
            updateSparkles(t);
            if(starMesh && starMesh.visible) starMesh.rotation.y+=0.02;
            if(ribbonMesh && ribbonMesh.visible) ribbonMesh.material.map.offset.x-=0.005;
            if(backgroundStars) backgroundStars.rotation.y = t*0.015;
            composer.render();
        }
    </script>
</body>
</html>